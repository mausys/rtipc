/**
 * @file rtipc.h
 * @brief Shared-memory interprocess message transport.
 *
 * This library provides wait-free message passing between two processes
 * using shared memory. Communication occurs through *channels* grouped
 * inside a @ref ri_vector_t.
 *
 * Each channel is unidirectional, but the overall connection is typically
 * bidirectional:
 *
 *   - A **producer** in one process corresponds to a **consumer**
 *     in the peer process.
 *   - A **consumer** in one process corresponds to a **producer**
 *     in the peer process.
 *
 * In other words, channel roles are *local to each process*.
 *
 * All push/pop operations are non-blocking. Eventfds may be used for readiness
 * notification but are not required.
 */

#pragma once

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>


#ifdef __cplusplus
extern "C" {
#endif


/**
 * @typedef ri_vector_t
 * @brief Opaque handle to a vector resource connecting producer and consumer channels
 * mapped to the same shared memory region.
 */
typedef struct ri_vector ri_vector_t;

/**
 * @typedef ri_log_fn
 * @brief Prototype for a user-defined log handler.
 *
 * This callback is invoked by the library whenever a log message is
 * emitted. It follows a printf-style interface using a @c va_list.
 *
 * @param priority Log severity level (for example, syslog-style levels).
 * @param file     Source file name where the log originated.
 * @param line     Source line number where the log originated.
 * @param func     Function name where the log originated.
 * @param format   printf-style format string describing the message.
 * @param ap       Argument list corresponding to @p format.
 *
 * @note The callback must not modify or reuse @p ap after returning.
 *       If the arguments need to be processed multiple times, use
 *       @c va_copy.
 */
typedef void (*ri_log_fn)(int priority,
                          const char *file,
                          const char *line,
                          const char *func,
                          const char *format,
                          va_list ap);

/**
 * @brief Sets a custom log handler for the library.
 *
 * Installs a user-provided logging callback that will receive all
 * subsequent log messages generated by the library.
 *
 * Passing @c NULL restores the default logging behavior.
 *
 * @param log_handler Pointer to the log handler function, or @c NULL.

 */
void ri_set_log_handler(ri_log_fn log_handler);


/**
 * @typedef ri_info_t
 * @brief Opaque user payload associated with a channel or vector.
 *
 * This structure is used to transfer arbitrary user-defined data
 * from the server to the client.
 */
typedef struct ri_info {
  size_t size; /**< Size of the payload in bytes */
  const void *data; /**< Pointer to read-only payload buffer */
} ri_info_t;


/**
 * @typedef ri_channel_t
 * @brief Configuration for creating a producer or consumer channel.
 *
 * This structure is only used during setup. The library copies the
 * values; the caller retains ownership after creation.
 */
typedef struct ri_channel {
  /**
   * Size of a single message in bytes.
   *
   * All messages sent through the channel must be exactly this size.
   */
  size_t msg_size;

  /**
   * Additional message capacity beyond the minimum queue length of 3.
   *
   * The total channel capacity is therefore (3 + add_msgs) messages.
   */
  unsigned add_msgs;

  /**
   * Event file descriptor used to signal the consumer.
   */
  int eventfd;

  /**
   * Optional user-defined metadata associated with the channel.
   *
   * This information is transmitted to the server during channel setup
   * and is not interpreted by the channel implementation.
   */
  ri_info_t info;

} ri_channel_t;


/**
 * @typedef ri_vector_config_t
 * @brief Configuration parameters for creating a vector resource.
 *
 * This structure defines the set of producer and consumer channels that
 * will be attached to the vector, along with optional user-defined
 * metadata. The configuration is provided at creation time and is not
 * modified by the vector implementation.
 */
typedef struct ri_config {

  /**
   * Array of consumer channel configurations.
   *
   * The array must be terminated by a sentinel element where @ref msg_size
   * is set to 0.
   */
  const ri_channel_t *consumers;

  /**
   * Array of producer channel configurations.
   *
   * The array must be terminated by a sentinel element where @ref msg_size
   * is set to 0.
   */
  const ri_channel_t *producers;

  /**
   * Optional user-defined metadata associated with the vector.
   *
   * This information is transmitted during vector creation and is not
   * interpreted by the vector implementation.
   */
  ri_info_t info;

} ri_config_t;


/**
 * @typedef ri_resource_t
 * @brief Descriptor used to create a vector via an external setup mechanism.
 *
 * This structure contains the channel configuration and file descriptors
 * required to construct a vector when the connection is established
 * out-of-band (for example, over D-Bus).
 *
 * Unlike @ref ri_vector_config_t, this form may contain live file
 * descriptors and is intended for interprocess resource handoff.
 */
typedef struct ri_resource {

  /**
   * Array of consumer channel descriptors.
   *
   * Each entry corresponds to a consumer channel configuration. The array
   * must be terminated by a sentinel element where @ref msg_size is set to 0.
   *
   * The @ref eventfd field of each entry is either a valid eventfd used for
   * notification or -1 if event-based signaling is not used.
   */
  ri_channel_t *consumers;

  /**
   * Array of producer channel descriptors.
   *
   * Each entry corresponds to a producer channel configuration. The array
   * must be terminated by a sentinel element where @ref msg_size is set to 0.
   *
   * The @ref eventfd field of each entry is either a valid eventfd used for
   * notification or -1 if event-based signaling is not used.
   */
  ri_channel_t *producers;

  /**
   * Optional user-defined metadata associated with the vector.
   *
   * This information is transferred during setup and is not interpreted
   * by the vector implementation.
   */
  ri_info_t info;

  /**
   * File descriptor referring to the shared memory backing the vector.
   *
   * This must reference a valid shared memory object suitable for mapping
   * by all participating processes.
   */
  int shmfd;

} ri_resource_t;


/**
 * @brief Creates an empty vector resource descriptor.
 *
 * Creates a resource capable of holding @p n_consumers consumer channels
 * and @p n_producers producer channels. The channel descriptors and the
 * shared memory file descriptor must be filled in by the caller before
 * the resource is used to construct a vector.
 *
 * This function is intended for server-side use when connection setup
 * is performed using an external or custom IPC mechanism.
 *
 * @param n_consumers Number of consumer channels to allocate space for
 * @param n_producers Number of producer channels to allocate space for
 * @param info        Optional metadata associated with the vector
 *
 * @return A newly allocated resource descriptor, or NULL on failure
 */
ri_resource_t* ri_resource_new(unsigned n_consumers, unsigned n_producers, const ri_info_t *info);


/**
 * @brief Creates a fully initialized vector resource from a configuration.
 *
 * Builds a @ref ri_resource_t based on the channel layout described in
 * @p config. The resulting resource contains the channel descriptors and
 * metadata needed to establish a shared-memory vector with a peer.
 *
 * This function is typically used on the client side when connection
 * establishment is handled via an external or custom IPC mechanism.
 * The returned resource can be transmitted to the server, which will
 * then attach to the described shared memory and channels.
 *
 * @param config Pointer to a static vector configuration
 *
 * @return A newly allocated resource descriptor, or NULL on failure
 */
ri_resource_t* ri_resource_alloc(const ri_config_t *config);


/**
 * @brief Destroys a vector resource descriptor.
 *
 * Frees only the memory and file descriptors still owned by this
 * @ref ri_resource_t. Any ownership already transferred to a
 * @ref ri_vector_t or its channels is not affected.
 *
 * After this call, @p rsc becomes invalid and must not be used again.
 */
void ri_resource_delete(ri_resource_t *rsc);


/**
 * @brief Creates a channel vector from a resource descriptor.
 *
 * @param rsc    Resource descriptor describing shared memory and channels
 * @param server If true, this side acts as the server side of the
 *               connection; otherwise as the client side.
 *
 * The server/client distinction determines which channels are treated
 * as producers or consumers locally. The peer process will see the
 * opposite roles.
 */
ri_vector_t* ri_vector_new(ri_resource_t *rsc, bool server);


/**
 * @brief Destroys a channel vector.
 *
 * Releases all channels still owned by the @ref ri_vector_t instance.
 * Channels whose ownership has already been transferred via
 * @ref ri_vector_take_consumer or @ref ri_vector_take_producer are not
 * affected.
 *
 * After this call, @p vec becomes invalid and must not be used again.
 */
void ri_vector_delete(ri_vector_t *vec);


/**
 * @brief Returns the user-defined metadata associated with the vector.
 *
 * Retrieves the application-specific information previously attached to
 * the vector instance.
 *
 * @param vec Pointer to the vector.
 * @return The metadata associated with the vector.
 */
ri_info_t ri_vector_info(const ri_vector_t *vec);


/**
 * @brief Initialize the shared memory region with default values.
 *
 * Must be called exactly once by the server before any
 * channel operations are performed. This function prepares the shared
 * memory state required for subsequent communication.
 *
 * @param vec Pointer to the vector associated with the shared memory.
 */
void ri_vector_init_shm(const ri_vector_t *vec);


/**
 * @brief Get the number of consumer channels.
 *
 * @param vec Pointer to the vector.
 * @return The number of consumer channels.
 */
unsigned ri_vector_num_consumers(const ri_vector_t *vec);


/**
 * @brief Get the number of producer channels.
 *
 * @param vec Pointer to the vector.
 * @return The number of producer channels.
 */
unsigned ri_vector_num_producers(const ri_vector_t *vec);


/**
 * @typedef ri_consumer_t
 * @brief Handle for receiving messages from a peer process.
 *
 * A consumer reads messages written by a producer in the *other* process.
 */
typedef struct ri_consumer ri_consumer_t;


/**
 * @enum ri_consume_result_t
 * @brief Result codes returned by ri_consumer_pop.
 *
 * These values describe the outcome of attempting to consume data from
 * a channel.
 */
typedef enum ri_consume_result {
  /**
   * A fatal error occurred.
   *
   * Indicates an unrecoverable condition such as internal corruption,
   * invalid state, or a system-level failure. The caller should treat
   * the channel as unusable after this result.
   */
  RI_CONSUME_RESULT_ERROR = -2,

  /**
   * No message has ever been produced.
   *
   * The channel has not yet received any data since creation.
   */
  RI_CONSUME_RESULT_NO_MSG = -1,

  /**
   * No new message since the last successful consume.
   *
   * Data was previously available, but nothing new has been produced
   * since the caller last consumed a message.
   */
  RI_CONSUME_RESULT_NO_UPDATE = 0,

  /**
   * One message was successfully consumed.
   *
   * At least one message newer than the last consumed one was available.
   */
  RI_CONSUME_RESULT_SUCCESS = 1,

  /**
   * Messages were lost due to queue overflow.
   *
   * One or more older messages were overwritten by producers before
   * they could be consumed. The message returned is the **oldest message
   * still available** in the queue, meaning a gap in the data stream
   * has occurred.
   */
  RI_CONSUME_RESULT_DISCARDED = 2,

} ri_consume_result_t;


/**
 * @brief ri_vector_take_consumer get a pointer to a consumer
 *
 * @param shm shared memory object
 * @param index consumer channel index
 * @return pointer to consumer; NULL on error
 */
ri_consumer_t* ri_vector_take_consumer(ri_vector_t *vec, unsigned index);


/**
 * @brief Destroys a consumer channel.
 *
 * Releases all resources associated with the consumer. After this call,
 * @p consumer becomes invalid and must not be used again.
 *
 * If this is the last remaining channel attached to the shared memory,
 * the shared memory region is also destroyed.
 */
void ri_consumer_delete(ri_consumer_t *consumer);


/**
 * @brief Returns a pointer to the consumer's current message buffer.
 *
 * The pointer remains valid until the next call to
 * @ref ri_consumer_pop or @ref ri_consumer_flush.
 * If no message was produced yet, NULL will be returned.
 *
 * The returned memory is owned by the library and must not be freed.
 */
const void* ri_consumer_msg(const ri_consumer_t *consumer);


/**
 * @brief Advances to the next available message in the queue.
 *
 * After a successful call, @ref ri_consumer_msg returns the newly
 * consumed message.
 *
 * This function never blocks.
 */
ri_consume_result_t ri_consumer_pop(ri_consumer_t *consumer);


/**
 * @brief ri_consumer_flush get message from the head, discarding all older messages
 *
 * @param consumer pointer to consumer
 * @return result
 */
ri_consume_result_t ri_consumer_flush(ri_consumer_t *consumer);


/**
 * @brief ri_consumer_msg_size get message size
 *
 * @param consumer pointer to consumer
 * @return size of message
 */
size_t ri_consumer_msg_size(const ri_consumer_t *consumer);
\

/**
 * @brief Returns the eventfd used by this consumer.
 *
 * The consumer retains ownership and will close the descriptor when
 * @ref ri_consumer_delete is called.
 */
int ri_consumer_eventfd(const ri_consumer_t *consumer);


/**
 * @brief Transfers ownership of the eventfd to the caller.
 *
 * After this call, the consumer no longer uses or closes the descriptor.
 */
int ri_consumer_take_eventfd(ri_consumer_t *consumer);


/**
 * @brief Returns the user-defined metadata associated with the consumer channel.
 *
 * Retrieves the application-specific information previously attached to
 * the consumer instance.
 *
 * @param consumer Pointer to the consumer channel.
 * @return The metadata associated with the consumer channel.
 */
ri_info_t ri_consumer_info(const ri_consumer_t *consumer);


/**
 * @brief Delete the user-defined metadata associated with a consumer channel.
 *
 * Frees any application-specific information attached to the consumer.
 * This should be called when the metadata is no longer needed to avoid
 * unnecessary memory usage.
 *
 * @param consumer Pointer to the consumer.
 */
void ri_consumer_free_info(ri_consumer_t *consumer);


/**
 * @typedef ri_producer_t
 * @brief Handle for sending messages to a peer process.
 *
 * A producer writes messages that will be read by a consumer in the
 * *other* process.
 */
typedef struct ri_producer ri_producer_t;

/**
 * @enum ri_produce_result_t
 * @brief Result codes returned by a produce (push) operation.
 *
 * These values describe the outcome of attempting to add a message to
 * a producer channel.
 */
typedef enum ri_produce_result {

  /**
   * A fatal error occurred.
   *
   * Indicates an unrecoverable condition such as internal corruption,
   * invalid state, or a system-level failure. The caller should treat
   * the channel as unusable after this result.
   */
  RI_PRODUCE_RESULT_ERROR = -2,

  /**
   * The message was not queued because the queue was full.
   *
   * This result can only occur when using @c ri_producer_try_push.
   * No existing messages were modified or removed.
   */
  RI_PRODUCE_RESULT_FAIL = -1,

  /**
   * The message was successfully added to the queue.
   *
   * No messages were lost as a result of this operation.
   */
  RI_PRODUCE_RESULT_SUCCESS = 1,

  /**
   * The message was added, but the oldest queued message was discarded.
   *
   * This result can only occur when using @c ri_producer_force_push.
   * Data loss has occurred because the queue was already full.
   */
  RI_PRODUCE_RESULT_DISCARDED = 2,

} ri_produce_result_t;


/**
 * @brief ri_rtipc_take_producer get a pointer to a producer
 *
 * @param shm shared memory object
 * @param index producer channel index
 * @return pointer to producer; NULL on error
 */
ri_producer_t* ri_vector_take_producer(ri_vector_t *vec, unsigned index);


/**
 * @brief Destroys a producer channel.
 *
 * Releases all resources associated with the consumer. After this call,
 * @p producer becomes invalid and must not be used again.
 *
 * If this is the last remaining channel attached to the shared memory,
 * the shared memory region is also destroyed.
 */
void ri_producer_delete(ri_producer_t *producer);


/**
 * @brief Returns a pointer to the producer's current writable message buffer.
 *
 * The application writes message data into this buffer, then submits it
 * using @ref ri_producer_try_push or @ref ri_producer_force_push.
 *
 * The pointer remains valid until the next push operation or until the
 * producer is deleted.
 */
void* ri_producer_msg(const ri_producer_t *producer);


/**
 * @brief ri_producer_force_push submits current message and get a new message
 *
 * @param producer pointer to producer
 * @return result
 */
ri_produce_result_t ri_producer_force_push(ri_producer_t *producer);


/**
 * @brief ri_producer_try_push submits current message and get a new message,
 * if queue is not full
 *
 * @param producer pointer to producer
 * @return result
 */
ri_produce_result_t ri_producer_try_push(ri_producer_t *producer);


/**
 * @brief ri_producer_msg_size get message size
 *
 * @param producer pointer to producer
 * @return size of message
 */
size_t ri_producer_msg_size(const ri_producer_t *producer);


/**
 * @brief Returns the eventfd used by this producer.
 *
 * The producer retains ownership and will close the descriptor when
 * @ref ri_producer_delete is called.
 */
int ri_producer_eventfd(const ri_producer_t *producer);


/**
 * @brief Transfers ownership of the eventfd to the caller.
 *
 * After this call, the producer no longer uses or closes the descriptor.
 */
int ri_producer_take_eventfd(ri_producer_t *producer);


/**
 * @brief Enables producer-side message caching.
 *
 * When caching is enabled, @ref ri_producer_msg returns a pointer to an
 * internal buffer owned by the producer instead of directly exposing the
 * shared memory slot. This cache is written back to shared memory on the
 * next successful push operation.
 *
 * Caching provides two important guarantees:
 *
 * - **Isolation from the peer:** The producer operates on a private copy
 *   of the message that cannot be modified by the consumer process. This
 *   protects reads from accidental corruption or malicious interference
 *   originating from the peer.
 *
 * - **Safe partial updates:** The cache is initialized with the current
 *   message contents, allowing the producer to modify only selected fields
 *   while the rest of the message remains valid. This prevents accidental
 *   reuse of undefined data from a previous message slot.
 *
 * The trade-off is that the channel is no longer zero-copy while caching
 * is enabled, as each push requires copying the cached buffer into shared
 * memory.
 *
 * @return 0 on success, negative on error
 */
int ri_producer_cache_enable(ri_producer_t *producer);


/**
 * @brief Disables message caching and writes cached data back.
 *
 * After this call, @ref ri_producer_msg returns a direct pointer to the
 * shared memory message slot again.
 */
void ri_producer_cache_disable(ri_producer_t *producer);


/**
 * @brief Returns the user-defined metadata associated with the producer channel.
 *
 * Retrieves the application-specific information previously attached to
 * the producer instance.
 *
 * @param producer Pointer to the producer channel.
 * @return The metadata associated with the producer channel.
 */
ri_info_t ri_producer_info(const ri_producer_t *producer);


/**
 * @brief Delete the user-defined metadata associated with a producer channel.
 *
 * Frees any application-specific information attached to the producer.
 * This should be called when the metadata is no longer needed to avoid
 * unnecessary memory usage.
 *
 * @param producer Pointer to the producer.
 */
void ri_producer_free_info(ri_producer_t *producer);


/**
 * @typedef ri_server_t
 * @brief Opaque handle representing a server that owns a listening Unix domain socket.
 */
typedef struct ri_server ri_server_t;



/**
 * @brief ri_server_new creates a server socket and starts listening
 *
 * @param path pathname of socket
 * @param backlog argument for listen
 *
 */
ri_server_t* ri_server_new(const char* path, int backlog);


/**
 * @brief ri_server_delete delete server
 * @param server
 */
void ri_server_delete(ri_server_t* server);


/**
 * @brief Get the server's Unix domain socket file descriptor.
 *
 * Returns the file descriptor of the Unix domain socket associated with
 * the given server instance. The descriptor remains owned by the server
 * and must not be closed by the caller.
 *
 * @param server Pointer to an initialized server instance.
 * @return File descriptor of the Unix domain socket.
 */
int ri_server_socket(const ri_server_t* server);

typedef bool (*ri_filter_fn)(const ri_resource_t* rsc, void *user_data);

/**
 * @brief Accepts a client connection and constructs a vector.
 *
 * @param socket   Unix Domain Socket ( socket(AF_UNIX, SOCK_SEQPACKET, 0) )
 * @param filter   Optional callback to accept (true) or reject (false)
 *                 a connection based on the requested resource
 * @param user_data Opaque pointer passed to @p filter
 *
 * @return A newly created vector on success, or NULL on failure/rejection
 */
ri_vector_t* ri_server_socket_accept(int socket, ri_filter_fn filter, void *user_data);

/**
 * @brief Accepts a client connection and constructs a vector.
 *
 * @param server   Listening server instance
 * @param filter   Optional callback to accept (true) or reject (false)
 *                 a connection based on the requested resource
 * @param user_data Opaque pointer passed to @p filter
 *
 * @return A newly created vector on success, or NULL on failure/rejection
 */
ri_vector_t* ri_server_accept(const ri_server_t* server, ri_filter_fn filter, void *user_data);



ri_vector_t* ri_client_socket_connect(int socket, const ri_config_t *vconfig);

ri_vector_t* ri_client_connect(const char *path, const ri_config_t *vconfig);



#ifdef __cplusplus
}
#endif
